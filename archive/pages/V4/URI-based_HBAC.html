<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Overview &#8212; FreeIPA  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <link rel="icon" href="../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Introduction" href="Use_Case_for_Views%3A_Collaboration.html" />
    <link rel="prev" title="Overview" href="Trust_to_Samba_AD_DC.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h1>
<p>A feature allowing Host Based Access Control to decide based not only on
triplet (user,service,hostname), but also on URI of the requested
resource.</p>
</section>
<section id="use-cases">
<h1>Use Cases<a class="headerlink" href="#use-cases" title="Permalink to this heading">¶</a></h1>
<p>In some services, it may be useful to base authorization decision on
what resource within the the service is being accessed.</p>
<p>For example, it is very common in web applications that different parts
of the web (with different URIs) are meant to be accessed by different
users: there is some public part, some user-only part, some part that
should be accessible to administrator only…</p>
<p>Consider a webserver with the following URIs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">webserver</span><span class="o">/</span><span class="n">application</span><span class="o">/</span><span class="n">public</span><span class="o">-</span><span class="n">content</span>
<span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">webserver</span><span class="o">/</span><span class="n">application</span><span class="o">/</span><span class="n">login</span><span class="o">-</span><span class="n">only</span><span class="o">/</span><span class="nb">all</span><span class="o">-</span><span class="n">users</span>
<span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">webserver</span><span class="o">/</span><span class="n">application</span><span class="o">/</span><span class="n">login</span><span class="o">-</span><span class="n">only</span><span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">user1</span>
<span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">webserver</span><span class="o">/</span><span class="n">application</span><span class="o">/</span><span class="n">login</span><span class="o">-</span><span class="n">only</span><span class="o">/</span><span class="n">admin</span>
</pre></div>
</div>
<p>Each of these parts needs different access rights; so far, HBAC only
supported deciding whether an authorized user is allowed to access the
whole non-public part of the web. Obviously, it is possible for the web
application to handle access rights of the users. It is, however, a good
idea to also handle this on level of service (Apache) for consistency,
centralization and security on multiple levels.</p>
<p>This feature is a RFE for ticket #5030.</p>
</section>
<section id="design">
<h1>Design<a class="headerlink" href="#design" title="Permalink to this heading">¶</a></h1>
<p>For this feature, we need to add the URI to HBAC rule in FreeIPA, make
SSSD able to determine authorization based on it, and give services some
way to communicate with SSSD in terms of URI-based HBAC.</p>
<section id="schema">
<h2>Schema<a class="headerlink" href="#schema" title="Permalink to this heading">¶</a></h2>
<p>URI is a part of HBAC rule. It is interpreted as a prefix which decides
whether the HBAC rule that would otherwise match (if it wasn’t for this
feature) matches (the URI attribute is a prefix of resource’s URI) or it
does not (the URI attribute is not a prefix of resource’s URI). FreeIPA
itself merely stores this attribute and allows its adding, deletion and
editation; it doesn’t act based on it in any way. Because there are two
parts of URI with different interpretation and meaning (host, schema,
port VS path - the rest of URI), we store these two parts separately -
the first one as a case-insensitive UTF-8 string and the second as
case-sensitive UTF-8 string.</p>
<p>SSSD is a daemon running on service’s local machine and deciding based
on HBAC rules. It is also possible to use other approaches, for example
the application can ask FreeIPA’s LDAP and decide itself based on
provided data. In case of SSSD, there is already HBAC capability - we
need to ensure it becomes URI-aware and it gets important data from both
sides - the URI prefix from FreeIPA and the URI to match from the
service requesting authorization. We can achieve this using
already-existing channels improved to also transfer URI. The prefix is
an attribute of HBAC rule and can be retrieved from FreeIPA’s LDAP using
LDAP provider (URI would be accessible by anyone who has access to the
HBAC rule). There are multiple ways of getting the accessed URI from the
service.</p>
<p>By using SSSD, it is not required for the service requsting
authorization to be able to decide based on authorization data it
obtains itself. While there are some minimal changes necessary (in case
of Apache, an authorization module must exist), the service merely needs
to ask for authorization (providing, user, hostname, service, URI) and
receive result.</p>
<p>There are multiple ways of communicating with SSSD, PAM and Infopipe
were considered. As there are already some applications using PAM and it
seems to be a good interface for this use case, SSSD expects the
application to use PAM, setting PAM environment variable to URI of the
requested resource. PAM responder uses system bus to communicate with
IPA provider in SSSD.</p>
<figure class="align-default" id="id3">
<img alt="sssd_pam.png" src="../../../_images/Sssd_pam.png" />
<figcaption>
<p><span class="caption-text">sssd_pam.png</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="evaluation">
<h2>Evaluation<a class="headerlink" href="#evaluation" title="Permalink to this heading">¶</a></h2>
<p>There are multiple possible approaches to comparing the requested
resource’s URI with URI in HBAC. In all of them, I use only the part of
URI after hostname as hostname and service are already matched as part
of selecting HBAC rules to evaluate in terms of matching URI.</p>
<ul class="simple">
<li><p>Equal string - only match an HBAC rule if there is the same string
(maybe case insensitive comparison?) as the requested URI; that would
mean a lot of HBAC rules differing only in specified URI and is
probably not a feasible approach</p></li>
<li><p><strong>Prefix</strong> - match HBAC rule &lt;=&gt; HBAC rule URI is a prefix of
requested URI. The problem is, in web applications, the longer URI
usually means stricter access rules. This means we must do the
longest-prefix matching. This is the solution I have chosen: matching
any rule with host+scheme+port exactly equal to the requested
scheme+host+port and having the URI’s path that is the longest prefix
of the requested URI’s path. (See examples below)</p></li>
<li><p>Regular expression - the most powerful interpretation of URI in HBAC
rule, Perl-compatible regular expression should be able to cover any
situation admin should need. They even support lookarounds which is
very useful, see example. PCRE library is already used in SSSD so
this adds no dependency and is a big boost to usability of the
feature.</p></li>
</ul>
</section>
<section id="example-how-it-can-not-work">
<span id="id1"></span><h2>Example - how it can not work<a class="headerlink" href="#example-how-it-can-not-work" title="Permalink to this heading">¶</a></h2>
<p>Consider webapp that has, among others, these pages:
<a class="reference external" href="http://hostname.net/app/auth/user1">http://hostname.net/app/auth/user1</a> <a class="reference external" href="http://hostname.net/app/auth/user42">http://hostname.net/app/auth/user42</a>
<a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a></p>
<p>We want to set the following access rights:</p>
<ul class="simple">
<li><p>Any authenticated user can access <a class="reference external" href="http://hostname.net/app/X">http://hostname.net/app/X</a> for X
being any</p></li>
</ul>
<p>user’s name except admin.</p>
<ul class="simple">
<li><p>Only admin can access <a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a> (so: while
any user</p></li>
</ul>
<p>can access anything with prefix <a class="reference external" href="http://hostname.net/app">http://hostname.net/app</a>, only admin can
access <a class="reference external" href="http://hostname.net/app/admin">http://hostname.net/app/admin</a>).</p>
<p>As we see, the longer the URI, the stricter access control rules. This
leads us to a concept of prefix-matching the URI’s: whenever the URI in
rule is a prefix of the requested resource’s URI, the rule matches in
terms of URI.</p>
<p>The way HBAC rules are interpreted, however, is currently such that
whenever any HBAC rule matches, the access is allowed. It is a correct
behavior when only con- sidering (user,service,host), but it causes a
problem when trying to include URI as a matching parameter. As shown in
the last item of a goal list, we need to have a way to allow every URI
with certain prefix A except URI’s with certain prefix B where A is a
prefix of B. In other words, we need to exclude a subset from a set of
URI’s described by certain HBAC rule. This is not possible when matching
any one rule causes access authorization.</p>
<p>How the rules would look (omitted HOST any SERVICE any everywhere):</p>
<ul class="simple">
<li><p>ALLOW any URI <a class="reference external" href="http://hostname.net/app/auth/">http://hostname.net/app/auth/</a></p></li>
<li><p>ALLOW admin URI <a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a></p></li>
</ul>
<p>This does not work ! While the sec ond rule only allows admin to access
<a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a>, the first rule allows any user to
access everything with prefix <a class="reference external" href="http://hostname.net/app/auth/">http://hostname.net/app/auth/</a> , including
<a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a> . We can accidentally allow access to
larger set than intended and there is no way to set exceptions from that
set. In this example, there is actually no way to set the rules
correctly so they achieve the goal, except using every possible prefix
other than the intended exception.</p>
<p>To solve the problem of exception from a set of allowed URI’s, we could
come up with a concept of DENY rules. The approach would mean allowing
access when any ALLOW rule matches and no DENY rule matches. A DENY rule
would otherwise be the very same rule as an ALLOW rule. That would not
be completely new for FreeIPA – at certain point in time, there actually
were both ALLOW and DENY rules.</p>
<p>DENY rules were, however, dropped from FreeIPA. The reason for this is
that we believe that access rules should always be described positively
– listing all accesses that are allowed, rather than listing what is not
allowed and thus risking we forget something or make a mistake that
would allow access that should not be allowed. Another reason is that
when we, for some reason, don’t evaluate an ALLOW rule, the result is
denial of service at worst, while failing to evaluate a DENY rule could
allow access that should not be allowed. It seems DENY rules are
absolutely not intended to be added again.</p>
<p>Furthermore, merely adding DENY rules would not be sufficient; for
example, there would be no easy way to come up with rules for our
example. We would need to deny access to
<a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a> to large or infinite number of users
as the access would by allowed by first rule. The rules would look
something like:</p>
<ul class="simple">
<li><p>ALLOW any URI <a class="reference external" href="http://hostname.net/app/auth/">http://hostname.net/app/auth/</a></p></li>
<li><p>DENY user1 URI <a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a></p></li>
<li><p>DENY user42 URI <a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a></p></li>
</ul>
<p>This could be solved by only matching the user-wise most specific rule
or giving the rules some order, e.g.:</p>
<ul class="simple">
<li><p>1 ALLOW any URI <a class="reference external" href="http://hostname.net/app/auth/">http://hostname.net/app/auth/</a></p></li>
<li><p>2 DENY any URI <a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a></p></li>
<li><p>3 ALLOW admin URI <a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a></p></li>
</ul>
<p>This would be a fully working solution, allowing exceptions, describing
infinite number of cases (both URI- and user- wise) in a relatively
small number of rules, and relatively readable. Still, there are
drawbacks:</p>
<ul class="simple">
<li><p>It is not easy to determine a rule to compare which one of the rules
is more</p></li>
</ul>
<p>specific user-wise. It would also be very error-prone.</p>
<ul class="simple">
<li><p>Adding order to rules would mean a significant change in their
semantics which</p></li>
</ul>
<p>would be hardly accepted</p>
<ul class="simple">
<li><p>DENY rules will probably never be accepted</p></li>
<li><p>There are better and simpler solutions, described further</p></li>
</ul>
</section>
<section id="example-how-it-works">
<span id="id2"></span><h2>Example - how it works<a class="headerlink" href="#example-how-it-works" title="Permalink to this heading">¶</a></h2>
<p>Using the previous notion, we would in many cases create a pair of rules
for subsets we wish to exclude some users from – an ALLOW rule allowing
access to certain subset of users, and a DENY rule which is the same
except it denies any user access to the same location (which is
necessary in case there is an ALLOW rule allowing access to some URI
which is a prefix of this location’s URI). The more specific or latter
of those (depending on which approach we would choose) two rules would
be the ALLOW rule and the result would be only allowing access to that
URI to certain users.</p>
<p>In previous example, this exactly happens: rule 1 allows access to
<a class="reference external" href="http://hostname">http://hostname</a>. net/app/auth to anyone and to allow access to
<a class="reference external" href="http://hostname.net/app/auth/">http://hostname.net/app/auth/</a> admin to admin only, we first need to deny
everyone access there by rule 2 before allowing it again for admin only
by rule 3.</p>
<p>It is easy to understand why the DENY rule could be there implicitly –
when admin allows access to some resource to some user, he means that
user only and all other users should be denied. However, there is
another rule that allows access to anyone - the first one. To solve this
problem, we can state that we only want to decide based on the rule with
longest prefix match. Even if there are multiple rules matching, we are
only interested in the most specific one. This allows us not to use DENY
rules at all because when there is no ALLOW rule, access is denied
implicitly, and the more general rule allowing access to a superset of
the more specific rule would be ignored. We could use the same rules as
in the previous example, just ignore the ordering and drop the DENY
rule:</p>
<ul class="simple">
<li><p><strong>ALLOW any URI</strong><a class="reference external" href="http://hostname.net/app/auth/">http://hostname.net/app/auth/</a></p></li>
<li><p><strong>ALLOW admin URI</strong><a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a></p></li>
</ul>
<p>The first rule allows anyone access to <a class="reference external" href="http://hostname.net/app/auth">http://hostname.net/app/auth</a>,
except for those URIs which have URI <a class="reference external" href="http://hostname/app/auth">http://hostname/app/auth</a> as a
proper prefix. The second rule’s URI is the first rule’s URI’s proper
prefix, thus the first rule is ignored for any URI matching URI of the
second rule, regardless whether the first rule’s URI matches or not.
This serves as implicit deny for everyone if their access does not match
rule 2, regardless whether it would match rule 1 or not. Rule 2 then
allows admin access to <a class="reference external" href="http://hostname.net/app/auth/admin">http://hostname.net/app/auth/admin</a>, the implicit
DENY making this the exclusive access right for admin.</p>
</section>
<section id="compatibility">
<h2>Compatibility<a class="headerlink" href="#compatibility" title="Permalink to this heading">¶</a></h2>
<p>If there is no URI in PAM request, we match any HBAC rule that would
match without this feature. In that case, we presume the application is
not interested in URI. This means effectively ignoring URI and matching
even rules with non-matching URI when specific URI is not requested.</p>
<p>This is a solution I picked because of backwards compatibility - because
we of course can not change behavior of previous versions and these
versions, not aware of URI-based HBAC, would allow any rule that matches
in terms of other attributes: user, host and service.</p>
<p>This solution might cause problems and is not ideal: it might be seen as
problematic that when the service does not ask for any specific URI, the
is always granted if there is any rule matching in terms of other
attributes, even if it does not match URI-wise. Also, when using old
version of pam_sss or SSSD, the same situation happens as if the
application didn’t include URI in the request.</p>
<p>I haven’t however, found any better solution that would be fully
backwards-compatible. I’d be glad for suggestions.</p>
</section>
</section>
<section id="feature-management">
<h1>Feature Management<a class="headerlink" href="#feature-management" title="Permalink to this heading">¶</a></h1>
<section id="ui">
<h2>UI<a class="headerlink" href="#ui" title="Permalink to this heading">¶</a></h2>
<p>There are two new fields in HBAC rule details for adding URI separated
into two parts: scheme+host+port and path</p>
</section>
<section id="cli">
<h2>CLI<a class="headerlink" href="#cli" title="Permalink to this heading">¶</a></h2>
<p>There are subcommands for “ipa” command to list and modify URI, these
are generated automatically.</p>
</section>
</section>
<section id="how-to-test">
<span id="how-to-test39"></span><h1>How to Test<a class="headerlink" href="#how-to-test" title="Permalink to this heading">¶</a></h1>
<p>There are unit tests in git.</p>
<p>To test manually:</p>
<ul class="simple">
<li><p>Have a working FreeIPA, SSSD registered as FreeIPA client, Apache,
some web application, mod_hbacauthz_pam.</p></li>
<li><p>Set mod_hbacauthz_pam to “require pam-account “ in some location in
Apache.</p></li>
<li><p>Use some authentication method, for example Kerberos, in that
location, be logged in (let’s use example “/application/login”)</p></li>
<li><p>Set HBAC rules so that without this feature, one HBAC rule would
match</p></li>
<li><p>Set URI in that HBAC rule to some prefix matching the page’s URI
path; connect the page, notice you are authorized (e.g.
“/application”)</p></li>
<li><p>Set URI in that HBAC rule to some prefix NOT matching the page’s URI
path; connect the page, notice you are NOT authorized (e.g.
“/whatever”)</p></li>
</ul>
</section>
<section id="test-plan">
<h1>Test Plan<a class="headerlink" href="#test-plan" title="Permalink to this heading">¶</a></h1>
<p>HBAC rules can be modified properly and authorization works as it should</p>
</section>
<section id="questions">
<h1>Questions<a class="headerlink" href="#questions" title="Permalink to this heading">¶</a></h1>
<ul class="simple">
<li><p>For backwards compatibility, lack of URI in request means any URI is
matched (as described above). Is it a good idea? Any other solution?</p></li>
<li><p>How about multiple URI’s in one HBAC rule? Is it a good idea? How to
interpret combinations of host+scheme+port and URI paths in that
case?</p></li>
</ul>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/freeipa-logo-small.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, FreeIPA Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/archive/pages/V4/URI-based_HBAC.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>